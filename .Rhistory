# List of CRAN packages
cran_packages <- c("ATbounds", "stagedtrees", "salso", "mcclust.ext")
# Install missing CRAN packages
for (pkg in cran_packages) {
if (!require(pkg, character.only = TRUE)) {
install.packages(pkg)
}
}
# Install mcclust from GitHub if not installed
if (!require("mcclust", character.only = TRUE)) {
# Install devtools if not installed
if (!require("devtools", character.only = TRUE)) {
install.packages("devtools")
}
devtools::install_github("sarawade/mcclust")
}
library(ATbounds) ## Package with dataset
library(stagedtrees)
library(salso)
library(mcclust.ext)
data("EFM")
# Convert the dataset to a data.frame and drop the 'year' column
data <- as.data.frame(EFM[ , !names(EFM) %in% "year"])
# Convert each column to a factor with levels 'Yes' and 'No'
data <- lapply(data, function(x) {
factor(x, levels = c(0, 1), labels = c("No", "Yes"))
})
# Convert the list back to a data.frame and order variables
data <- as.data.frame(data)
data <- data[,c(3,4,5,1,2)]
### Choose a starting tree for the MCMC and subset of data for uncertainty
tree <- stndnaming(stages_hc(full(data)))
n_burn <- 1000
plot(tree)
# List of CRAN packages
cran_packages <- c("ATbounds", "stagedtrees", "salso", "mcclust.ext")
# Install missing CRAN packages
for (pkg in cran_packages) {
if (!require(pkg, character.only = TRUE)) {
install.packages(pkg)
}
}
# Install mcclust from GitHub if not installed
if (!require("mcclust", character.only = TRUE)) {
# Install devtools if not installed
if (!require("devtools", character.only = TRUE)) {
install.packages("devtools")
}
devtools::install_github("sarawade/mcclust")
}
library(ATbounds) ## Package with dataset
library(stagedtrees)
library(salso)
library(mcclust.ext)
data("EFM")
# Convert the dataset to a data.frame and drop the 'year' column
data <- as.data.frame(EFM[ , !names(EFM) %in% "year"])
# Convert each column to a factor with levels 'Yes' and 'No'
data <- lapply(data, function(x) {
factor(x, levels = c(0, 1), labels = c("No", "Yes"))
})
# Convert the list back to a data.frame and order variables
data <- as.data.frame(data)
colnames(data)
data <- data[,c(5,3,4,2,1)]
### Choose a starting tree for the MCMC and subset of data for uncertainty
tree <- stndnaming(stages_hc(full(data)))
plot(tree)
n_burn <- 1000
thin <- 2
n_save <- 1000
a <- 1
prior <- "Heckerman"
scope <- names(tree$stages)[c(3,4)]
beta <- list(monitor = 0.3)
#FOR CRP
update_CRP <- TRUE
update_SM <- TRUE
library("e1071")
source("mcmc_crp_distances.R")
setwd("~/Documents/GitHub/bayesian_stagedtrees")
source("mcmc_crp_distances.R")
ciao <- mcmc_crp_distances(tree,n_save = n_save,n_burn = n_burn, thin = thin, a = 1, kappa = 1, csi = 1/8, prior = prior, scope = scope, beta=beta, update_SM=update_SM, update_CRP=update_CRP)
## Burn-in and thinning
result <- ciao$chain_out
## Check some measure of convergence
x <- lapply(result,logLik)
plot(1:length(x),x,type="l")
nstages <- function(tree) sum(unlist(lapply(tree$stages,function(i) length(unique(i)))))
y <- lapply(result,nstages)
plot(1:length(y),y,type="l")
## This should be already within the MCMC but to be sure I do it here too, just renaming
result <- lapply(result,stndnaming)
## Create plots chatgpt
process_variable <- function(v, result, estimate_B, estimate_VI, lower, upper, horizontal) {
# Create a matrix for each 'v' across all 'result'
mat <- t(sapply(result, function(res) res$stages[[v]]))
# Perform salso with Binder loss
estimate_B$stages[[v]] <- salso(mat, loss = "binder")
# Perform salso with VI loss
estimate_VI$stages[[v]] <- salso(mat, loss = "VI")
# Compute credible ball for VI distance
ball <- credibleball(estimate_VI$stages[[v]], mat, c.dist = "VI", alpha = 0.1)
# Update lower, upper, and horizontal stages
lower$stages[[v]] <- ball$c.lowervert[1,]
upper$stages[[v]] <- ball$c.uppervert[1,]
horizontal$stages[[v]] <- ball$c.horiz[1,]
# Return the updated objects
list(estimate_B = estimate_B, estimate_VI = estimate_VI, lower = lower, upper = upper, horizontal = horizontal)
}
# Initialize the objects
estimate_VI <- estimate_B <- lower <- upper <- horizontal <- result[[1]]
# Use lapply to loop over 'scope' and process each variable
for (v in scope) {
results <- process_variable(v, result, estimate_B, estimate_VI, lower, upper, horizontal)
estimate_B <- results$estimate_B
estimate_VI <- results$estimate_VI
lower <- results$lower
upper <- results$upper
horizontal <- results$horizontal
}
par(mfrow=c(2,2),mar=c(0,0,0,0))
plot(estimate_VI)
plot(horizontal)
plot(lower)
plot(upper)
diff(ce_randomized(estimate_VI, outcome = "cesarean", treatment = "monitor")[, 2])
library("stagedtrees")
randomize <- function(object, var, p = NULL, ignore = object$name_unobserved){
kk <- length(object$tree[[var]])
if (is.null(p)){
p <- rep.int(1/kk, kk)
}
names(p) <- object$tree[[var]]
tmp <- object$stages[[var]]
object$stages[[var]][!(tmp %in% ignore)] <- "randomized"
object$prob[[var]] <- c(list(randomized = p), object$prob[[var]][ignore])
object$prob[[var]] <- object$prob[[var]][!is.na(names(object$prob[[var]]))]
return(object)
}
ce_randomized <- function(object, outcome, treatment){
object0 <- randomize(object, treatment)
xx <- c(NA)
names(xx) <- outcome
res <- sapply(object$tree[[outcome]], function(vo){
xx[1] <- vo
prob(object0, xx, conditional_on = as.data.frame(object$tree[treatment]), na0 = FALSE)
})
dimnames(res) <- object$tree[c(treatment, outcome)]
return(res)
}
get_stages_ <- function(x, i, context){
tree <- x$tree
ixv <- which(i == names(tree))
tree1 <- tree[1:(ixv - 1)]
tree1[names(context)] <- as.list(context)
more <- rev(expand.grid(rev(tree1), stringsAsFactors = FALSE))
ixs <- vapply(1:nrow(more), function(rr) {
cpath <- unlist(more[rr, ])
stagedtrees:::tree_idx(cpath, tree)
}, FUN.VALUE = 1)
return(ixs)
}
ce_propscorestrat <- function(model, outcome, treatment, ignore = model$name_unobserved){
stgs <- unique(model$stages[[treatment]])
stgs <- stgs[!(stgs %in% ignore)]
strata <- sapply(stgs, function(stage){
get_path(model, treatment, stage)
}, simplify = FALSE)
tmp <- model$stages[[outcome]]
kk <- sum(! (tmp %in% ignore))
model$stages[[outcome]][! (tmp %in% ignore)] <- paste0(1:kk)
for (i in 1:length(strata)){
nn <- names(strata)[i]
for (j in 1:nrow(strata[[i]])){
todo <- get_stages_(model, outcome, strata[[i]][j,])
model$stages[[outcome]][todo] <- paste0(nn, 1:length(todo))
}
}
model <- sevt_fit(model)
probstrata <- sapply(strata, function(str) sum(prob(model, str)))
cestrata <- sapply(names(strata), function(ns){
str <- strata[[ns]]
todo <- model$stages[[outcome]][get_stages_(model, outcome, str[1,])]
A <- simplify2array(model$prob[[outcome]][todo])
colnames(A) <- model$tree$Treatment
A * probstrata[ns]
}, simplify = FALSE)
cestrata <- simplify2array(cestrata)
wok <- apply(cestrata, 3, function(xx) !any(is.na(xx)))
t(apply(cestrata[,,wok], c(1,2), sum) / sum(probstrata[wok]))
}
diff(ce_randomized(estimate_VI, outcome = "cesarean", treatment = "monitor")[, 2])
result
ce_diffs <- sapply(result, function(model) {
diff(ce_randomized(sevt_fit(model, data, lambda = a/2), outcome = "cesarean", treatment = "monitor")[, 2])
})
ce_diffs
library(ggplot2)
ggplot(data = data.frame(ce_diffs = ce_diffs), aes(x = ce_diffs)) +
geom_histogram(bins = 20, color = "black", fill = "blue", alpha = 0.7) +
geom_vline(xintercept = vertical_line, color = "red", linetype = "dashed", size = 1) +
labs(
title = paste("Sample Size:", sample_size),
x = "Causal Effect",
y = "Frequency"
) +
theme_minimal()
ggplot(data = data.frame(ce_diffs = ce_diffs), aes(x = ce_diffs)) +
geom_histogram(bins = 20, color = "black", fill = "blue", alpha = 0.7) +
labs(
title = paste("Sample Size:", sample_size),
x = "Causal Effect",
y = "Frequency"
) +
theme_minimal()
ggplot(data = data.frame(ce_diffs = ce_diffs), aes(x = ce_diffs)) +
geom_histogram(bins = 20, color = "black", fill = "blue", alpha = 0.7) +
labs(
x = "Causal Effect",
y = "Frequency"
) +
theme_minimal()
ggplot(data = data.frame(ce_diffs = ce_diffs), aes(x = ce_diffs)) +
geom_histogram(bins = 15, color = "black", fill = "blue", alpha = 0.7) +
labs(
x = "Causal Effect",
y = "Frequency"
) +
theme_minimal()
ggplot(data = data.frame(ce_diffs = ce_diffs), aes(x = ce_diffs)) +
geom_histogram(bins = 12, color = "black", fill = "blue", alpha = 0.7) +
labs(
x = "Causal Effect",
y = "Frequency"
) +
theme_minimal()
ggplot(data = data.frame(ce_diffs = ce_diffs), aes(x = ce_diffs)) +
geom_histogram(bins = 10, color = "black", fill = "blue", alpha = 0.7) +
labs(
x = "Causal Effect",
y = "Frequency"
) +
theme_minimal()
ggplot(data = data.frame(ce_diffs = ce_diffs), aes(x = ce_diffs)) +
geom_histogram(bins = 12, color = "black", fill = "blue", alpha = 0.7) +
labs(
x = "Causal Effect",
y = "Frequency"
) +
theme_minimal()
ggplot(data = data.frame(ce_diffs = ce_diffs), aes(x = ce_diffs)) +
geom_histogram(bins = 20, color = "black", fill = "blue", alpha = 0.7) +
geom_vline(xintercept = mean(ce_diffs), color = "red", linetype = "dashed", size = 1) +
labs(
x = "Causal Effect",
y = "Frequency"
) +
theme_minimal()
ggplot(data = data.frame(ce_diffs = ce_diffs), aes(x = ce_diffs)) +
geom_histogram(bins = 12, color = "black", fill = "blue", alpha = 0.7) +
geom_vline(xintercept = mean(ce_diffs), color = "red", linetype = "dashed", size = 1) +
labs(
x = "Causal Effect",
y = "Frequency"
) +
theme_minimal()
View(data)
diff(ce_randomized(sevt_fit(result[[1]], data, lambda = a/2), outcome = "cesarean", treatment = "monitor")[, 2])
diff(ce_randomized(sevt_fit(result[[2]], data, lambda = a/2), outcome = "cesarean", treatment = "monitor")[, 2])
diff(ce_randomized(sevt_fit(result[[3]], data, lambda = a/2), outcome = "cesarean", treatment = "monitor")[, 2])
diff(ce_randomized(sevt_fit(estimate_VI, data, lambda = a/2), outcome = "cesarean", treatment = "monitor")[, 2])
diff(ce_randomized(sevt_fit(estimate_B, data, lambda = a/2), outcome = "cesarean", treatment = "monitor")[, 2])
