n_burn
thin
prior
update_SM
kappa_val
a
scope
beta
source("mcmc_crp_distances.R")
# Run MCMC for each combination of csi and kappa
ciao <- mcmc_crp_distances(tree, n_save = n_save, n_burn = n_burn, thin = thin,
a = a, kappa = kappa_val, csi = csi_val, prior = prior,
scope = scope, beta = beta, update_SM = update_SM,
update_CRP = update_CRP)
source("mcmc_crp_distances.R")
# Generate new data for each sample size
data <- sample_from(tree_def, size = sample_size)
tree <- stndnaming(stages_fbhc(full(data)))
# Check and regenerate data if necessary
while (any(tree$ctables$X6[,1] == 0 & tree$ctables$X6[,2] == 0)) {
data <- sample_from(tree_def, size = sample_size)
tree <- stndnaming(stages_fbhc(full(data)))
}
# Run MCMC for each combination of csi and kappa
ciao <- mcmc_crp_distances(tree, n_save = n_save, n_burn = n_burn, thin = thin,
a = a, kappa = kappa_val, csi = csi_val, prior = prior,
scope = scope, beta = beta, update_SM = update_SM,
update_CRP = update_CRP)
n_tot <- n_burn + thin * n_save
# Check the inputs (use check_mcmc function as before, omitted here for brevity)
# priors <- comp_prior(stndnaming(tree), a)
if(is.null(scope)){scope <- sevt_varnames(tree)[-1]}
pb <- txtProgressBar(min = 0, max = n_tot, style = 3)
#Objects for CRP update
n_v <- length(scope)
alloc_v <- vector("list", length = n_v)
priors_v <- vector("list", length = n_v)
n_out_v <- rep(NA, n_v)
N_v <- sapply(tree$stages[scope], length)
for(iv in 1:n_v){
v <- scope[iv]
n_out_v[iv] <- length(tree$prob[[v]][[1]])
alloc_v[[iv]] <- tree$stages[[v]]
priors_v[[iv]] <- rep(a/n_out_v[iv],n_out_v[iv])
}
K_v <- sapply(alloc_v, function(x){length(unique(x))})
nj_v <- lapply(alloc_v, table)
#Compute Hamming distances between stages paths
#these are fixed because the tree is fixed
n_vars <- length(tree$tree)
n_cat <- apply(matrix(1:n_vars,ncol = 1), 1, function(i){length(tree$prob[[i]][[1]])})
n_paths <- prod(n_cat[-n_vars])
tree_paths <- matrix(0, n_paths, n_vars)
for(iv in 1:(n_vars-1)){
n_cat_iv <- n_cat[iv]
if(iv < n_vars - 1){
exp_prod <- prod(n_cat[(iv+1):(n_vars-1)])
}else{
exp_prod <- 1
}
rep_cat <- c(apply(matrix(1:n_cat_iv, ncol = 1), 1, function(i){rep(i,exp_prod)}))
#Use recycling
tree_paths[,iv+1] <- rep_cat
}
#Now remove duplicates
tree_paths_list <- vector("list",length = n_vars)
for(iv in 1:n_vars){
tree_paths_list[[iv]] <- unique(tree_paths[,1:iv])
}
#WE NEED to extend the above for non-binary trees
dist_H <- vector("list", length = n_v)
for(iv in 1:n_v){
iv_pos <- match(scope[iv], names(tree$tree))
N_v_iv <- N_v[iv]
mat <- matrix(0, N_v_iv, N_v_iv)
for(i1 in 1:(N_v_iv-1)){
for(i2 in (i1+1):N_v_iv){
p_v1 <- tree_paths_list[[iv_pos]][i1,]
p_v2 <- tree_paths_list[[iv_pos]][i2,]
mat[i1,i2] <- hamming.distance(p_v1, p_v2)
mat[i2,i1] <- mat[i1,i2]
}
}
dist_H[[iv]] <- mat
}
scope
n_v
iv <-1
iv_pos <- match(scope[iv], names(tree$tree))
N_v_iv <- N_v[iv]
mat <- matrix(0, N_v_iv, N_v_iv)
N_v_iv
N_v
n_tot <- n_burn + thin * n_save
# Check the inputs (use check_mcmc function as before, omitted here for brevity)
# priors <- comp_prior(stndnaming(tree), a)
if(is.null(scope)){scope <- sevt_varnames(tree)[-1]}
pb <- txtProgressBar(min = 0, max = n_tot, style = 3)
#Objects for CRP update
n_v <- length(scope)
n_v
alloc_v <- vector("list", length = n_v)
priors_v <- vector("list", length = n_v)
n_out_v <- rep(NA, n_v)
N_v <- sapply(tree$stages[scope], length)
N_v
n_out_v
tree$stages[scope]
library(stagedtrees)
library("e1071")
library(salso)
library(fossil)
## Definisco l'albero
tree_def <- list(X1 = c("no","yes"),
X2 = c("no","yes"),
X3 = c("no","yes"),
X4 = c("no","yes"),
X5 = c("no","yes"),
X6 = c("no","yes"))
## Lo creo come oggetto per pacchetto stagedtrees
tree_def <- sevt(tree_def, full= F)
tree_def$stages$X2 <- c("1","2")
tree_def$stages$X3 <- c("1","2","1","3")
tree_def$stages$X4 <- c("1","2","3","4","1","1","3","4")
tree_def$stages$X5 <- rep(c("1","2","3","4"),4)
tree_def$stages$X6 <- rep(c("1","2","1","2",
"3","2","3","2",
"9","9","11","12",
"13","13","15","12"),2)
tree_def <- stndnaming(tree_def)
## Assegno probabilita all'albero
## Per tutte le variabili precedenti metto 50/50 cosi da avere osservazioni in tutti i paths
tree_def$prob <- list()
tree_def$prob$X1 <- list("NA"=c("no"= 0.6,"yes" = 0.4))
tree_def$prob$X2 <- list("1" = c("no"= 0.5,"yes" = 0.5),
"2" = c("no"= 0.4,"yes" = 0.6))
tree_def$prob$X3 <- list("1" = c("no"= 0.4,"yes" = 0.6),
"2" = c("no"= 0.5,"yes" = 0.5),
"3" = c("no"= 0.7,"yes" = 0.3))
tree_def$prob$X4 <- list("1" = c("no"= 0.5,"yes" = 0.5),
"2" = c("no"= 0.4,"yes" = 0.6),
"3" = c("no"= 0.3,"yes" = 0.7),
"4" = c("no"= 0.7,"yes" = 0.3))
tree_def$prob$X5 <- list("1" = c("no"= 0.5,"yes" = 0.5),
"2" = c("no"= 0.4,"yes" = 0.6),
"3" = c("no"= 0.3,"yes" = 0.7),
"4" = c("no"= 0.7,"yes" = 0.3))
tree_def$prob$X6 <- list("1" = c("no"= 0.2,"yes" = 0.8),
"2" = c("no"= 0.7,"yes" = 0.3),
"3" = c("no"= 0.3,"yes" = 0.7),
"4" = c("no"= 0.5,"yes" = 0.5),
"5" = c("no"= 0.6,"yes" = 0.4),
"6" = c("no"= 0.4,"yes" = 0.6),
"7" = c("no"= 0.8,"yes" = 0.2),
"8" = c("no"= 0.9,"yes" = 0.1))
n_burn <- 1000
thin <- 2
n_save <- 1000
update_CRP <- TRUE
update_SM <- TRUE
scope <- "X6"
beta <- list(monitor = 0.3)
a <- 1
prior <- "Heckerman"
kappa <- 1
csi <- 0.4
source("mcmc_crp_distances.R")
# Generate new data for each sample size
data <- sample_from(tree_def, size = sample_size)
tree <- stndnaming(stages_fbhc(full(data)))
# Check and regenerate data if necessary
while (any(tree$ctables$X6[,1] == 0 & tree$ctables$X6[,2] == 0)) {
data <- sample_from(tree_def, size = sample_size)
tree <- stndnaming(stages_fbhc(full(data)))
}
# Run MCMC for each combination of csi and kappa
ciao <- mcmc_crp_distances(tree, n_save = n_save, n_burn = n_burn, thin = thin,
a = a, kappa = kappa_val, csi = csi_val, prior = prior,
scope = scope, beta = beta, update_SM = update_SM,
update_CRP = update_CRP)
source("mcmc_crp_distances.R")
# Run MCMC for each combination of csi and kappa
ciao <- mcmc_crp_distances(tree, n_save = n_save, n_burn = n_burn, thin = thin,
a = a, kappa = kappa_val, csi = csi_val, prior = prior,
scope = scope, beta = beta, update_SM = update_SM,
update_CRP = update_CRP)
# Burn-in and thinning
result <- ciao$chain_out
result[[1]]
?sevt_fit
lapply(results, function(model) {
sevt_fit(model,data,lambda = a/2)
})
lapply(result, function(model) {
sevt_fit(model,data,lambda = a/2)
})
lapply(result, function(model) {
diff(ce_randomized(sevt_fit(model,data,lambda = a/2), outcome = "X6", treatment = "X5")[, 2])
})
ciao <- lapply(result, function(model) {
diff(ce_randomized(sevt_fit(model,data,lambda = a/2), outcome = "X6", treatment = "X5")[, 2])
})
hist(ciao)
hist(sapply(ciao))
ciao <- sapply(result, function(model) {
diff(ce_randomized(sevt_fit(model,data,lambda = a/2), outcome = "X6", treatment = "X5")[, 2])
})
hist(ciao)
dev.off()
hist(ciao)
csi_values <- 1/32
sample_sizes <- 5000
kappa_values <- 1
kappa_values <- c(0.1,1)
# Initialize a list to store estimate_VI results
estimate_VI_results <- list()
# Loop over all sample sizes
for (sample_size in sample_sizes) {
# Generate new data for each sample size
data <- sample_from(tree_def, size = sample_size)
tree <- stndnaming(stages_fbhc(full(data)))
# Check and regenerate data if necessary
while (any(tree$ctables$X6[,1] == 0 & tree$ctables$X6[,2] == 0)) {
data <- sample_from(tree_def, size = sample_size)
tree <- stndnaming(stages_fbhc(full(data)))
}
# Loop over all combinations of csi and kappa for the current sample size
for (csi_val in csi_values) {
for (kappa_val in kappa_values) {
# Run MCMC for each combination of csi and kappa
ciao <- mcmc_crp_distances(tree, n_save = n_save, n_burn = n_burn, thin = thin,
a = a, kappa = kappa_val, csi = csi_val, prior = prior,
scope = scope, beta = beta, update_SM = update_SM,
update_CRP = update_CRP)
# Burn-in and thinning
result <- ciao$chain_out
# Initialize the storage for current combination
estimate_VI <- result[[1]]
# Store data object
estimate_VI$data <- data
# Store salso results for each variable in scope
for (v in scope) {
# Create matrix for variable v
mat <- t(sapply(result, function(res) res$stages[[v]]))
# Perform salso with VI loss for estimate_VI
estimate_VI$stages[[v]] <- salso(mat, loss = "VI")
}
# Store the ce_randomized diff() output for each model
ce_diffs <- sapply(result, function(model) {
diff(ce_randomized(sevt_fit(model, data, lambda = a/2), outcome = "X6", treatment = "X5")[, 2])
})
# Add ce_diffs to the estimate_VI object
estimate_VI$ce_diffs <- ce_diffs
# Store the result in the main list
estimate_VI_results[[paste0("sample_", sample_size, "_csi_", csi_val, "_kappa_", kappa_val)]] <- estimate_VI
}
}
}
# Initialize a list to store estimate_VI results
estimate_VI_results <- list()
# Loop over all sample sizes
for (sample_size in sample_sizes) {
# Generate new data for each sample size
data <- sample_from(tree_def, size = sample_size)
tree <- stndnaming(stages_fbhc(full(data)))
# Check and regenerate data if necessary
while (any(tree$ctables$X6[,1] == 0 & tree$ctables$X6[,2] == 0)) {
data <- sample_from(tree_def, size = sample_size)
tree <- stndnaming(stages_fbhc(full(data)))
}
# Loop over all combinations of csi and kappa for the current sample size
for (csi_val in csi_values) {
for (kappa_val in kappa_values) {
estimate_VI_results[[paste0("sample_", sample_size, "_csi_", csi_val, "_kappa_", kappa_val)]] <- list()
# Run MCMC for each combination of csi and kappa
ciao <- mcmc_crp_distances(tree, n_save = n_save, n_burn = n_burn, thin = thin,
a = a, kappa = kappa_val, csi = csi_val, prior = prior,
scope = scope, beta = beta, update_SM = update_SM,
update_CRP = update_CRP)
# Burn-in and thinning
result <- ciao$chain_out
# Initialize the storage for current combination
estimate_VI <- result[[1]]
# Store data object
estimate_VI_results[[paste0("sample_", sample_size, "_csi_", csi_val, "_kappa_", kappa_val)]][["data"]] <- data
# Store salso results for each variable in scope
for (v in scope) {
# Create matrix for variable v
mat <- t(sapply(result, function(res) res$stages[[v]]))
# Perform salso with VI loss for estimate_VI
estimate_VI$stages[[v]] <- salso(mat, loss = "VI")
}
# Store the ce_randomized diff() output for each model
ce_diffs <- sapply(result, function(model) {
diff(ce_randomized(sevt_fit(model, data, lambda = a/2), outcome = "X6", treatment = "X5")[, 2])
})
# Add ce_diffs to the estimate_VI object
estimate_VI_results[[paste0("sample_", sample_size, "_csi_", csi_val, "_kappa_", kappa_val)]][["ce_diffs"]] <- ce_diffs
# Store the result in the main list
estimate_VI_results[[paste0("sample_", sample_size, "_csi_", csi_val, "_kappa_", kappa_val)]][["tree"]] <- estimate_VI
}
}
}
hist(estimate_VI_results$sample_5000_csi_0.03125_kappa_0.1$ce_diffs)
estimate_VI_results[[1]]$data
estimate_VI_results[[1]]$tree
estimate_VI_results[[1]]$ce_diffs
hist(estimate_VI_results[[1]]$ce_diffs)
hist(estimate_VI_results[[2]]$ce_diffs)
library(stagedtrees)
library("e1071")
library(salso)
library(fossil)
## Definisco l'albero
tree_def <- list(X1 = c("no","yes"),
X2 = c("no","yes"),
X3 = c("no","yes"),
X4 = c("no","yes"),
X5 = c("no","yes"),
X6 = c("no","yes"))
## Lo creo come oggetto per pacchetto stagedtrees
tree_def <- sevt(tree_def, full= F)
tree_def$stages$X2 <- c("1","2")
tree_def$stages$X3 <- c("1","2","1","3")
tree_def$stages$X4 <- c("1","2","3","4","1","1","3","4")
tree_def$stages$X5 <- rep(c("1","2","3","4"),4)
tree_def$stages$X6 <- rep(c("1","2","1","2",
"3","2","3","2",
"9","9","11","12",
"13","13","15","12"),2)
tree_def <- stndnaming(tree_def)
## Assegno probabilita all'albero
## Per tutte le variabili precedenti metto 50/50 cosi da avere osservazioni in tutti i paths
tree_def$prob <- list()
tree_def$prob$X1 <- list("NA"=c("no"= 0.6,"yes" = 0.4))
tree_def$prob$X2 <- list("1" = c("no"= 0.5,"yes" = 0.5),
"2" = c("no"= 0.4,"yes" = 0.6))
tree_def$prob$X3 <- list("1" = c("no"= 0.4,"yes" = 0.6),
"2" = c("no"= 0.5,"yes" = 0.5),
"3" = c("no"= 0.7,"yes" = 0.3))
tree_def$prob$X4 <- list("1" = c("no"= 0.5,"yes" = 0.5),
"2" = c("no"= 0.4,"yes" = 0.6),
"3" = c("no"= 0.3,"yes" = 0.7),
"4" = c("no"= 0.7,"yes" = 0.3))
tree_def$prob$X5 <- list("1" = c("no"= 0.5,"yes" = 0.5),
"2" = c("no"= 0.4,"yes" = 0.6),
"3" = c("no"= 0.3,"yes" = 0.7),
"4" = c("no"= 0.7,"yes" = 0.3))
tree_def$prob$X6 <- list("1" = c("no"= 0.2,"yes" = 0.8),
"2" = c("no"= 0.7,"yes" = 0.3),
"3" = c("no"= 0.3,"yes" = 0.7),
"4" = c("no"= 0.5,"yes" = 0.5),
"5" = c("no"= 0.6,"yes" = 0.4),
"6" = c("no"= 0.4,"yes" = 0.6),
"7" = c("no"= 0.8,"yes" = 0.2),
"8" = c("no"= 0.9,"yes" = 0.1))
n_burn <- 1000
thin <- 2
n_save <- 1000
update_CRP <- TRUE
update_SM <- TRUE
scope <- "X6"
beta <- list(monitor = 0.3)
a <- 1
prior <- "Heckerman"
kappa <- 1
csi <- 0.4
source("mcmc_crp_distances.R")
# Define vectors of values for csi and kappa
# Define vectors of values for csi, kappa, and sample sizes
csi_values <- c(0, 1/64, 1/32, 1/16, 1/8, 1/4, 1/2, 1)
kappa_values <- c(0.01, 0.05, 0.1, 0.5, 1, 5)
sample_sizes <- c(500, 1000, 2500, 5000,7500, 10000)
# Initialize a list to store estimate_VI results
estimate_VI_results <- list()
# Loop over all sample sizes
for (sample_size in sample_sizes) {
# Generate new data for each sample size
data <- sample_from(tree_def, size = sample_size)
tree <- stndnaming(stages_fbhc(full(data)))
# Check and regenerate data if necessary
while (any(tree$ctables$X6[,1] == 0 & tree$ctables$X6[,2] == 0)) {
data <- sample_from(tree_def, size = sample_size)
tree <- stndnaming(stages_fbhc(full(data)))
}
# Loop over all combinations of csi and kappa for the current sample size
for (csi_val in csi_values) {
for (kappa_val in kappa_values) {
estimate_VI_results[[paste0("sample_", sample_size, "_csi_", csi_val, "_kappa_", kappa_val)]] <- list()
# Run MCMC for each combination of csi and kappa
ciao <- mcmc_crp_distances(tree, n_save = n_save, n_burn = n_burn, thin = thin,
a = a, kappa = kappa_val, csi = csi_val, prior = prior,
scope = scope, beta = beta, update_SM = update_SM,
update_CRP = update_CRP)
# Burn-in and thinning
result <- ciao$chain_out
# Initialize the storage for current combination
estimate_VI <- result[[1]]
# Store data object
estimate_VI_results[[paste0("sample_", sample_size, "_csi_", csi_val, "_kappa_", kappa_val)]][["data"]] <- data
# Store salso results for each variable in scope
for (v in scope) {
# Create matrix for variable v
mat <- t(sapply(result, function(res) res$stages[[v]]))
# Perform salso with VI loss for estimate_VI
estimate_VI$stages[[v]] <- salso(mat, loss = "VI")
}
# Store the ce_randomized diff() output for each model
ce_diffs <- sapply(result, function(model) {
diff(ce_randomized(sevt_fit(model, data, lambda = a/2), outcome = "X6", treatment = "X5")[, 2])
})
# Add ce_diffs to the estimate_VI object
estimate_VI_results[[paste0("sample_", sample_size, "_csi_", csi_val, "_kappa_", kappa_val)]][["ce_diffs"]] <- ce_diffs
# Store the result in the main list
estimate_VI_results[[paste0("sample_", sample_size, "_csi_", csi_val, "_kappa_", kappa_val)]][["tree"]] <- estimate_VI
}
}
}
library(ggplot2)
library(reshape2)
library(gridExtra)
# Extract unique stage counts for each entry
results <- data.frame(Sample_Size = integer(), Csi = numeric(), Kappa = numeric(), Unique_Stages = integer(), Hamming = integer(), Local = integer(),Parents = integer(), Rand= numeric())
for (key in names(estimate_VI_results)) {
# Parse the sample, csi, and kappa values from the key
parts <- unlist(strsplit(key, "_"))
sample_size <- as.integer(parts[2])
csi <- as.numeric(parts[4])
kappa <- as.numeric(parts[6])
# Calculate the number of unique stages for X6
unique_stages <- length(unique(estimate_VI_results[[key]]$tree$stages$X6))
hamming <- sum(hamming_stages(tree_def,estimate_VI_results[[key]]$tree,return_tree = T)$X6)
locals <- length(as_parentslist(estimate_VI_results[[key]]$tree)$X6$local)
parents <- length(as_parentslist(estimate_VI_results[[key]]$tree)$X6$parents)
rand <- rand.index(as.numeric(tree_def$stages$X6),as.numeric(estimate_VI_results[[key]]$tree$stages$X6))
# Add the result to the dataframe
results <- rbind(results, c( sample_size, csi, kappa, unique_stages,hamming,locals,parents,rand))
}
results <- as.data.frame(results)
colnames(results) <- c("Sample_Size", "Csi","Kappa","Unique_Stages","Hamming","Locals","Parents","Rand")
results$Unique_Stages <- results$Unique_Stages - length(unique(tree_def$stages$X6))
heatmap_list <- list()
for (sample_size in sample_sizes) {
# Subset data for the current sample size
data_subset <- subset(results, Sample_Size == sample_size)
# Create heatmap
p <- ggplot(data_subset, aes(x = as.factor(Kappa), y = as.factor(Csi), fill = Hamming)) +
geom_tile() +
scale_fill_gradient2(name = "Rand", low = "red", mid = "white", high = "blue", midpoint = 0) +
labs(title = paste("Sample Size:", sample_size), x = "Kappa", y = "Csi") +
theme_minimal()
# Append to list
heatmap_list[[as.character(sample_size)]] <- p
}
# Arrange heatmaps in a grid
do.call("grid.arrange", c(heatmap_list, ncol = 2))
heatmap_list <- list()
for (sample_size in sample_sizes) {
# Subset data for the current sample size
data_subset <- subset(results, Sample_Size == sample_size)
# Create heatmap
p <- ggplot(data_subset, aes(x = as.factor(Kappa), y = as.factor(Csi), fill = Rand)) +
geom_tile() +
scale_fill_gradient2(name = "Rand", low = "red", mid = "white", high = "blue", midpoint = 0) +
labs(title = paste("Sample Size:", sample_size), x = "Kappa", y = "Csi") +
theme_minimal()
# Append to list
heatmap_list[[as.character(sample_size)]] <- p
}
# Arrange heatmaps in a grid
do.call("grid.arrange", c(heatmap_list, ncol = 2))
heatmap_list <- list()
for (sample_size in sample_sizes) {
# Subset data for the current sample size
data_subset <- subset(results, Sample_Size == sample_size)
# Create heatmap
p <- ggplot(data_subset, aes(x = as.factor(Kappa), y = as.factor(Csi), fill = Unique_Stages)) +
geom_tile() +
scale_fill_gradient2(name = "Rand", low = "red", mid = "white", high = "blue", midpoint = 0) +
labs(title = paste("Sample Size:", sample_size), x = "Kappa", y = "Csi") +
theme_minimal()
# Append to list
heatmap_list[[as.character(sample_size)]] <- p
}
# Arrange heatmaps in a grid
do.call("grid.arrange", c(heatmap_list, ncol = 2))
plot(tree_def)
plot(estimate_VI_results$sample_10000_csi_0.5_kappa_0.5)
plot(estimate_VI_results$sample_10000_csi_0.5_kappa_0.5$tree)
par(mfrow=c(1,2))
plot(estimate_VI_results$sample_10000_csi_0.5_kappa_0.5$tree)
plot(tree_def)
hist(estimate_VI_results$sample_500_csi_0_kappa_0.01)
hist(estimate_VI_results$sample_500_csi_0_kappa_0.01$ce_diffs)
dev.off()
hist(estimate_VI_results$sample_500_csi_0_kappa_0.01$ce_diffs)
hist(estimate_VI_results$sample_1000_csi_0_kappa_0.01$ce_diffs)
hist(estimate_VI_results$sample_2500_csi_0_kappa_0.01$ce_diffs)
hist(estimate_VI_results$sample_5000_csi_0_kappa_0.01$ce_diffs)
hist(estimate_VI_results$sample_7500_csi_0_kappa_0.01$ce_diffs)
hist(estimate_VI_results$sample_10000_csi_0_kappa_0.01$ce_diffs)
hist(estimate_VI_results$sample_10000_csi_0.5_kappa_1$ce_diffs)
hist(estimate_VI_results$sample_10000_csi_0.5_kappa_1$ce_diffs)
4*0.3+5*0.7
20*(4*0.3+5*0.7)
4*0.25+5*0.75
4.75*20
0.45*4+0.55*5
4.55*20
20*(4*0.05+5*0.95)
20*(4*0.45+5*0.55)
saveRDS(estimate_VI_results,"Results/CS_Tree_Binary.rds")
